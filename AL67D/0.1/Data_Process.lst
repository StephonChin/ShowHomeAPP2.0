C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE DATA_PROCESS
OBJECT MODULE PLACED IN .\HexDocument\Data_Process.obj
COMPILER INVOKED BY: C:\Keil\C51\C51\BIN\C51.EXE PublicSrc\Data_Process.c BROWSE INCDIR(.\PrivateInc;.\PublicInc) DEBUG 
                    -OBJECTEXTEND PRINT(.\Data_Process.lst) TABS(2) OBJECT(.\HexDocument\Data_Process.obj)

line level    source

   1          /*******************************************************************************
   2            *
   3            * FILE NAME
   4            *           Data_Process.c
   5            *
   6            * NODE
   7            *           About horse run mode
   8            *             if the mode is run mode, ripple mode, flower bloom mode, polar light mode, color show mode,
   9            *             only AL91 or AL94 have horse function.
  10            *
  11            *             if the mode is show1, show2, or show3
  12            *             all the product have horse function.
  13            *
  14          *******************************************************************************/
  15          #include "Data_Process.h"
  16          
  17          //----------------------------------------------------------------------------
  18          // Gloable Parameters
  19          //----------------------------------------------------------------------------
  20          idata _Uint8          ChkSumH;
  21          idata _Uint8          ChkSumL;
  22          idata _Uint8          ChkSumRst;
  23          idata _Uint8          ChkSumRstSave;
  24          idata _Uint8          PowerOnNum;
  25          idata _Flag                     TestFlag = FALSE;
  26          
  27          
  28          
  29          //----------------------------------------------------------------------------
  30          // File Parameters
  31          //----------------------------------------------------------------------------
  32          idata _Uint8          NewChkSumH;
  33          idata _Uint8          NewChkSumL;
  34          idata _Uint8          ChkSumRstTime;
  35          idata _Flag             PasswordFlag;           //Allow set the password flag
  36          idata _Flag             SynRcvFlag;
  37          idata _Uint8          FlagChkTime;
  38          idata _Flag             FlagChkFlag;
  39          
  40          idata _Uint8                  NtcBanTime[2];
  41          idata _Flag                   NtcBanFlag;
  42          idata _Flag                   NtcBanInit;
  43          
  44          idata _Uint8                    TestTime = 0;
  45          
  46          
  47          
  48          
  49          
  50          /******************************************************************************
  51            *
  52            * COLOR_TABLE
  53            *
  54            * DESCRIPTION
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 2   

  55            *               Color value combine with R value, G value and B value,
  56            *               or  with R value, G value , B value and W value
  57            *
  58          *******************************************************************************/
  59          const _Uint8 COLOR_VECTOR[8][3] =
  60          {
  61            100,    0,      0,
  62              100,    0,      0,            //1:red
  63              0,      100,    0,            //2:green 
  64            100,    100,    0,            //3:r g
  65              0,      0,      100,          //4:blue
  66              100,    0,      100,          //5:r b
  67              0,      100,    100,          //6:g b
  68              100,    100,    100           //7:r g b
  69          };
  70          
  71          
  72          
  73          /************************************************************************************
  74            *
  75            * FUNCTION NAME   | User_Data_Init
  76            * INPUT         | None
  77            * OUTPUT      | None
  78            * BRIEF       | Initialize the user data after power on, include display
  79            *           mode, color theme, time count down hour and others
  80            *
  81          *************************************************************************************/
  82          void User_Data_Init(void)
  83          {
  84   1          if (PORT_KEY == RESET)
  85   1          {
  86   2              TestFlag = TRUE;
  87   2          }
  88   1          
  89   1          
  90   1        //-----------------------------------------------------------------
  91   1        // if the first time to power on
  92   1        //-----------------------------------------------------------------
  93   1          PowerOnNum = Byte_Read_From_APROM(APROM_POWER_ON_NUM);
  94   1        if (PowerOnNum != 0xAA)
  95   1        {
  96   2          DisplayData.ModeBuf     = 0x1;
  97   2          DisplayData.ColorValue    = 0x7;
  98   2          TimerData.CntDwnHour    = 0x6;
  99   2              MotorData.ModeBuf           = 0x1;
 100   2          ChkSumH           = 0;
 101   2          ChkSumL           = 0;
 102   2          ChkSumReply[0]        = '0';
 103   2          ChkSumReply[1]        = '0';
 104   2          ChkSumReply[2]        = '0';
 105   2          ChkSumReply[3]        = '0';
 106   2          ChkSumRst         = 0;
 107   2          PowerOnNum          = 0xAA;
 108   2          ChkSumRstSave       = 0;
 109   2          FlashSaveFlag       = TRUE;
 110   2          
 111   2          DisplayData.Mode      = 0x1;
 112   2          DisplayData.InitFlag    = TRUE;
 113   2              MotorData.Mode              = 0x1;
 114   2              MotorData.InitFlag          = TRUE;
 115   2              TimerData.InitFlag          = TRUE;
 116   2          Color_Value_Get(DisplayData.ColorValue);
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 3   

 117   2          return;
 118   2        }
 119   1        
 120   1        //-----------------------------------------------------------------
 121   1        // Get the mode from eprom after power on
 122   1        // When display mode equl 0 (means turn off all leds, then set
 123   1        // the mode to 0xA (color show), and save it to eprom
 124   1        //-----------------------------------------------------------------
 125   1          DisplayData.ModeBuf = Byte_Read_From_APROM(APROM_MODE);
 126   1        if (DisplayData.ModeBuf == 0 || (DisplayData.ModeBuf > 0x3 && DisplayData.ModeBuf < 0xB) || DisplayData.M
             -odeBuf > 0xD)
 127   1        {
 128   2          DisplayData.ModeBuf   = 0x1;
 129   2          FlashSaveFlag     = TRUE;
 130   2        }
 131   1        DisplayData.Mode      = DisplayData.ModeBuf;
 132   1        DisplayData.InitFlag    = TRUE;
 133   1        
 134   1        
 135   1        //---------------------------------------------------------------------
 136   1        // Get the color value from eprom after power on
 137   1        // When the color value is more than the COLOR_MAX, set it to COLOR_MAX
 138   1        // and save the value to eprom 
 139   1        //----------------------------------------------------------------------
 140   1          DisplayData.ColorValue  = Byte_Read_From_APROM(APROM_COLOR);
 141   1        if (DisplayData.ColorValue > COLOR_MAX)
 142   1        {
 143   2          DisplayData.ColorValue  = COLOR_MAX;
 144   2          FlashSaveFlag     = TRUE;
 145   2        }
 146   1        Color_Value_Get(DisplayData.ColorValue);
 147   1        
 148   1        
 149   1        //----------------------------------------------------------------------
 150   1        // Get the count down hour from eprom after power on,
 151   1        // if valid value is more than 8 , seit it to 6,
 152   1        // and save6 to eprom
 153   1        // Set the OnOffFlag
 154   1        //----------------------------------------------------------------------
 155   1          TimerData.CntDwnHour = Byte_Read_From_APROM(APROM_CNTDWN_HOUR);
 156   1        if (TimerData.CntDwnHour > 8 || (TimerData.CntDwnHour % 2 == 1))
 157   1        {
 158   2          TimerData.CntDwnHour  = 6;
 159   2          FlashSaveFlag     = TRUE;
 160   2        }
 161   1        TimerData.InitFlag  = TRUE;
 162   1        TimerData.OnOffFlag = TRUE;
 163   1        
 164   1        
 165   1        
 166   1          
 167   1          //-------------------------------------------------------------------------
 168   1        // Get the motor value from eprom
 169   1          //-------------------------------------------------------------------------
 170   1        MotorData.ModeBuf = Byte_Read_From_APROM(APROM_MOTOR);
 171   1        if (MotorData.ModeBuf > 2)
 172   1        {
 173   2          MotorData.ModeBuf   = 1;
 174   2          FlashSaveFlag     = TRUE;
 175   2        }
 176   1        MotorData.Mode      = MotorData.ModeBuf;
 177   1        MotorData.InitFlag    = TRUE;
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 4   

 178   1        
 179   1      
 180   1          
 181   1          
 182   1          //----------------------------------------------------------------------
 183   1          // Check the count
 184   1          // if power on 3 times in 5 seconds, reset the checksum
 185   1          // 1 -> write 0x55
 186   1          // 2 -> write 0xAA
 187   1          // 3 -> Reset
 188   1          //----------------------------------------------------------------------
 189   1          ChkSumRst   = Byte_Read_From_APROM(APROM_CHK_RST_CNT);
 190   1          ChkSumH     = Byte_Read_From_APROM(APROM_CHKSUM_H);
 191   1          ChkSumL     = Byte_Read_From_APROM(APROM_CHKSUM_L);
 192   1          if (ChkSumRst == 0)
 193   1          {
 194   2              ChkSumRstSave     = 0x55;
 195   2              FlashSaveFlag   = TRUE;
 196   2          }
 197   1          else if (ChkSumRst == 0x55)
 198   1          {
 199   2              ChkSumRstSave     = 0xAA;
 200   2              FlashSaveFlag   = TRUE;
 201   2          }
 202   1          else if (ChkSumRst == 0xAA)
 203   1          {
 204   2              ChkSumH       = 0;
 205   2              ChkSumL       = 0;
 206   2              ChkSumRstSave = 0;
 207   2              ChkSumRst     = 0;
 208   2              FlashSaveFlag = TRUE;
 209   2              
 210   2              DisplayData.Mode      = 0xFD;
 211   2              DisplayData.InitFlag  = TRUE;
 212   2          }
 213   1          
 214   1          ChkSumReply[0] = Hex_To_Char(ChkSumH >> 4);
 215   1          ChkSumReply[1] = Hex_To_Char(ChkSumH & 0x0F);
 216   1          ChkSumReply[2] = Hex_To_Char(ChkSumL >> 4);
 217   1          ChkSumReply[3] = Hex_To_Char(ChkSumL & 0x0F); 
 218   1      }
 219          
 220          
 221          
 222          /*************************************************************************************
 223            *
 224            * FUNCTION NAME   | Data_Process
 225            * INPUT           | None
 226            * OUTPUT          | None
 227            * DESCRIPTION     | Process all the data here. change the mode , color, timer or
 228            *                   other parameters after received valid data from CSR1010
 229            *
 230          ***************************************************************************************/
 231          void Data_Process(void)
 232          {
 233   1        /* Key Process */
 234   1        Key_Process();
 235   1          
 236   1          /* Detect the temperature */
 237   1          Tmprtr_Process();
 238   1        
 239   1        /* Timer Process */
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 5   

 240   1        Count_Down_Process();
 241   1        
 242   1        /* Password Process */
 243   1        Password_Process();
 244   1        
 245   1        /* Synchronize Process */
 246   1        Syn_Process();
 247   1        
 248   1        /* CSR1010 Process */
 249   1        CSR1010_Process();
 250   1      }
 251          
 252          /************************************************************
 253            *
 254            * @FunctonName  Key_Process
 255            * @Brief    Process the key
 256            *         Change the color and mode after short key
 257            */
 258          static void Key_Process(void)
 259          {
 260   1          if (TestFlag == TRUE)
 261   1          {
 262   2              PORT_HOT = HOT_ON;
 263   2              KeyStatus = KEY_IDLE;
 264   2              TestTime++;
 265   2              if (TestTime > 250)
 266   2              {
 267   3                  TestTime = 0;
 268   3                  PORT_HOT = HOT_OFF;
 269   3                  TestFlag = FALSE;
 270   3              }
 271   2          }
 272   1        //------------------------------------------------------
 273   1        // When key status is idle, return
 274   1        //------------------------------------------------------
 275   1        if (KeyStatus == KEY_IDLE)    return;
 276   1      
 277   1        
 278   1        //-------------------------------------------------------
 279   1        // Short Press
 280   1        //-------------------------------------------------------
 281   1        if (KeyStatus == KEY_SHORT)
 282   1        {
 283   2          //Temperature Ban
 284   2          NtcBanFlag = TRUE;
 285   2          NtcBanInit = TRUE;
 286   2          
 287   2          //clear the status
 288   2          KeyStatus = KEY_IDLE;
 289   2          
 290   2          //set data intialize flag
 291   2          DisplayData.InitFlag  = TRUE;
 292   2          
 293   2          // power on
 294   2          if (DisplayData.Mode == 0)
 295   2          {
 296   3            DisplayData.Mode    = DisplayData.ModeBuf;
 297   3            MotorData.Mode      = MotorData.ModeBuf;
 298   3            MotorData.InitFlag      = TRUE;
 299   3            
 300   3            if (DisplayData.ColorValue == 0x0 || DisplayData.ColorValue > 0x7)
 301   3            {
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 6   

 302   4              DisplayData.ColorValue  = 0x7;
 303   4              FlashSaveFlag           = TRUE;
 304   4            }
 305   3            Color_Value_Get(DisplayData.ColorValue);  
 306   3          }
 307   2          
 308   2          
 309   2              else if (DisplayData.Mode > 0xA)
 310   2              {
 311   3                  DisplayData.ModeBuf++;
 312   3                  DisplayData.Mode = DisplayData.ModeBuf;
 313   3                  if (DisplayData.ModeBuf > 0xD)
 314   3                  {
 315   4                      DisplayData.Mode            = 0;
 316   4                      MotorData.Mode              = 0;
 317   4                      MotorData.InitFlag          = TRUE;
 318   4                      DisplayData.ModeBuf         = 1;
 319   4                      DisplayData.ColorValue      = 1;
 320   4                  }
 321   3                  FlashSaveFlag                   = TRUE;
 322   3              }
 323   2              
 324   2              // change thecolor
 325   2          else
 326   2          { 
 327   3            // change color
 328   3                  DisplayData.ModeBuf = 1;
 329   3            DisplayData.ColorValue++;
 330   3            if (DisplayData.ColorValue > COLOR_MAX)
 331   3            {
 332   4              DisplayData.ColorValue = 0x1;
 333   4              DisplayData.ModeBuf = 0xB;
 334   4            }
 335   3                  DisplayData.Mode    = DisplayData.ModeBuf;
 336   3            FlashSaveFlag       = TRUE;
 337   3          }
 338   2              
 339   2          Color_Value_Get(DisplayData.ColorValue);
 340   2        }
 341   1        
 342   1        //long press to power off
 343   1        else
 344   1        if (KeyStatus == KEY_LONG)
 345   1        {
 346   2          KeyStatus = KEY_IDLE;
 347   2          if (DisplayData.Mode != 0)
 348   2          {
 349   3            DisplayData.Mode    = 0;
 350   3            DisplayData.InitFlag  = TRUE;
 351   3            MotorData.Mode      = 0;
 352   3            MotorData.InitFlag    = TRUE;
 353   3          }
 354   2        }
 355   1      }
 356          
 357          
 358          
 359          /**********************************************************************************
 360            *
 361            * FUNCTIONNAME      | Tmprtr_Process
 362            * INPUT             | None
 363            * OUTPUT            | None
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 7   

 364            * DESCRIPTION       | Detect the environment temperature
 365          ************************************************************************************/
 366          static void Tmprtr_Process(void)
 367          {
 368   1        //-------------------------------------------------------
 369   1        // The Temperature is less than 55
 370   1        //-------------------------------------------------------
 371   1        if (NtcStatus == NTC_IDLE || NtcStatus == NTC_HOT)
 372   1        {
 373   2          NtcBanTime[0] = 0;
 374   2          NtcBanTime[1] = 0;
 375   2          NtcBanFlag    = FALSE;
 376   2          return;
 377   2        }
 378   1        
 379   1        //-------------------------------------------------------
 380   1        // The Temperature is greater than 55 
 381   1        //-------------------------------------------------------
 382   1        if (NtcStatus == NTC_BAN)
 383   1        {
 384   2          if (NtcBanFlag == TRUE)
 385   2          {
 386   3            if (NtcBanInit == TRUE)
 387   3            {
 388   4              NtcBanInit = FALSE;
 389   4              NtcBanTime[0] = 0;
 390   4              NtcBanTime[1] = 0;
 391   4            }
 392   3            
 393   3            NtcBanTime[0]++;
 394   3            if (NtcBanTime[0] >= 50) //1s
 395   3            {
 396   4              NtcBanTime[0] = 0;
 397   4              NtcBanTime[1]++;
 398   4              if (NtcBanTime[1] >= 20) //20s
 399   4              {
 400   5                NtcBanTime[1] = 0;
 401   5                NtcBanFlag = FALSE;
 402   5              }
 403   4            }
 404   3          }
 405   2          
 406   2          //-----------------------------------------------------
 407   2          // after 20 seconds, turn off the LED & Motor
 408   2          //-----------------------------------------------------
 409   2          else
 410   2          {
 411   3            DisplayData.Mode    = 0;
 412   3            DisplayData.InitFlag  = TRUE;
 413   3            MotorData.Mode      = 0;
 414   3            MotorData.InitFlag    = TRUE;
 415   3          }
 416   2        }
 417   1        
 418   1        //------------------------------------------------------
 419   1        // When Temperature is less than 50 after 1h
 420   1        //------------------------------------------------------
 421   1        if (NtcStatus == NTC_BAN_EXIT)
 422   1        {
 423   2          NtcStatus = NTC_IDLE;
 424   2          //restore the Led & Motor work mode
 425   2          if (TimerData.OnOffFlag == TRUE)
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 8   

 426   2          {
 427   3            DisplayData.Mode    = DisplayData.ModeBuf;
 428   3            DisplayData.InitFlag  = TRUE;
 429   3            MotorData.Mode      = MotorData.ModeBuf;
 430   3            MotorData.InitFlag    = TRUE;
 431   3          }
 432   2        }
 433   1      }
 434          
 435          
 436          
 437          
 438          /************************************************************
 439            *
 440            * @FunctonName  Password_Process
 441            *
 442          *****/
 443          static void Password_Process(void)
 444          {
 445   1        static  _Uint8      PasswordTime; 
 446   1        
 447   1        // Reset checksum time caculate
 448   1        if (ChkSumRst != 0)
 449   1        {
 450   2          ChkSumRstTime++;
 451   2          if (ChkSumRstTime >= 250)
 452   2          {
 453   3            ChkSumRstTime = 0;
 454   3            ChkSumRst     = 0;
 455   3            ChkSumRstSave = 0;
 456   3            FlashSaveFlag = TRUE;
 457   3          }
 458   2        }
 459   1        
 460   1        
 461   1        //----------------------------------------------------------------------------------------
 462   1        // About Password Set
 463   1        //
 464   1        // * When received the single that allow set the password, then caculate 5 seconds
 465   1        //   if haven't received any password, reset the allow flag
 466   1        //-----------------------------------------------------------------------------------------
 467   1        if (PasswordFlag)
 468   1        {
 469   2          PasswordTime++;
 470   2          if (PasswordTime >= 250)        PasswordFlag = FALSE;
 471   2        }
 472   1        else
 473   1        {
 474   2          PasswordTime = 0;
 475   2        }
 476   1      }
 477          
 478          
 479          /****************************************************************************
 480           *
 481           * @FunctonName Syn_Process
 482           * if SynRcvFlag is TRUE(when received synchronize single),
 483             the next 3 seconds do not allowed to receive the same command
 484           
 485           * if the flag of synchronization is true, send data mode + serias + checksum
 486          
 487           * SynData[2] used for horse mode under AL91 or AL94
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 9   

 488           *
 489          ******************************************************************************/
 490          static void Syn_Process(void)
 491          {
 492   1          static  _Uint8      SynRcvTime  = 0;
 493   1        
 494   1        //-------------------------------------------------------------------------------------
 495   1        // About synchronizing single
 496   1        //
 497   1        
 498   1        //--------------------------------------------------------------------------------------
 499   1        if (SynRcvFlag == TRUE)
 500   1        {
 501   2          SynRcvTime++;
 502   2          if (SynRcvTime > 150)
 503   2          {
 504   3            SynRcvTime = 0;
 505   3            SynRcvFlag = FALSE;
 506   3          }
 507   2        }
 508   1        else
 509   1        {
 510   2          SynRcvTime = 0;
 511   2        }
 512   1      }
 513          
 514          
 515          
 516          /************************************************************
 517            *
 518            * @FunctonName  Count_Down_Process
 519            *
 520          *****/
 521          static void Count_Down_Process(void)
 522          {
 523   1        /* When TimerData.Status equals TIM_IDLE, exit this function */
 524   1        if (TimerData.Status == TIM_IDLE) return;
 525   1        
 526   1        /* Open */
 527   1        if (TimerData.Status == TIM_OPEN) 
 528   1        {
 529   2          TimerData.Status    = TIM_IDLE;
 530   2          DisplayData.Mode    = DisplayData.ModeBuf;
 531   2          DisplayData.InitFlag  = TRUE;
 532   2              
 533   2              MotorData.Mode          = MotorData.ModeBuf;
 534   2              MotorData.InitFlag      = TRUE;
 535   2          return;
 536   2        }
 537   1        
 538   1        /* Close */
 539   1        if (TimerData.Status == TIM_CLOSE)
 540   1        {
 541   2          TimerData.Status      = TIM_IDLE;
 542   2          DisplayData.Mode    = 0x0;
 543   2          DisplayData.InitFlag  = TRUE;
 544   2              
 545   2              MotorData.Mode          = 0;
 546   2              MotorData.InitFlag      = TRUE;
 547   2          return;
 548   2        }
 549   1      }
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 10  

 550          
 551          
 552          /****************************************************************************************
 553            *
 554            * FUNCTIONNAME    | CSR1010_Process
 555            * INPUT         | None
 556            * OUTPUT      | None
 557            * DESCRIPTION   | Send data to or received data from CSR1010
 558            *
 559          *****************************************************************************************/
 560          static void CSR1010_Process(void)
 561          {
 562   1        static  _Uint8    TypeReplyTime;
 563   1        static  _Flag       BtInitFlag;         //bluetooth intialization' flag
 564   1        static  _Uint8    FlagBuffer  = 0xFF;
 565   1            _Uint16   ChkSumBuf = 0;
 566   1      
 567   1        
 568   1        //-----------------------------------------------------------------------
 569   1        // if device haven't received any command within 500ms,
 570   1        // clear the flagstatus
 571   1        //-----------------------------------------------------------------------
 572   1        if (FlagChkFlag)
 573   1        {
 574   2          FlagChkTime++;
 575   2          if (FlagChkTime >= 25)
 576   2          {
 577   3            FlagChkTime   = 0;
 578   3            FlagBuffer    = 0xFF;
 579   3            FlagChkFlag   = FALSE;
 580   3          }
 581   2        }
 582   1        
 583   1      
 584   1        
 585   1        /* Check the received flag, when it is false, return */
 586   1        if (RcvFlag == FALSE)   return;
 587   1        
 588   1        
 589   1        /* Received the command from CSR1010
 590   1         * Clear the received flag        
 591   1         */
 592   1        RcvFlag     = FALSE;
 593   1        FlagChkFlag   = TRUE;
 594   1        FlagChkTime   = 0;
 595   1          BtRcvDataFlag = TRUE;
 596   1        
 597   1        
 598   1        /* CSR1010 Initialize         */
 599   1        if (BtInitFlag == FALSE)
 600   1        {
 601   2              //----------------------------------------------------------------------
 602   2              // if device haven't received command FD F0 FE within 1 second after power on,
 603   2              // send the type to CSR1010
 604   2              //-----------------------------------------------------------------------
 605   2              TypeReplyTime++;
 606   2          if (TypeReplyTime >= 150)
 607   2          {
 608   3            BtInitFlag      = TRUE;              
 609   3            SndData.SndStatus = SND_TYPE;
 610   3            SndData.DataBuf[0]  = 0x01;
 611   3            SndData.DataBuf[1]  = DEVICE_NAME_ONE;
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 11  

 612   3            SndData.DataBuf[2]  = DEVICE_NAME_TWO;
 613   3            SndData.DataBuf[3]  = DEVICE_NUM;
 614   3            SndData.DataBuf[4]  = MotorData.Mode;
 615   3            SndData.DataBuf[5]  = DisplayData.ColorValue;
 616   3            SndData.DataBuf[6]  = ChkSumH;
 617   3            SndData.DataBuf[7]  = ChkSumL;
 618   3          }
 619   2        }
 620   1          
 621   1          if (RcvData.DataBuf[0] == 0xF0)
 622   1          {            
 623   2              SndData.SndStatus = SND_TYPE;
 624   2              SndData.DataBuf[0]  = 0x01;
 625   2              SndData.DataBuf[1]  = DEVICE_NAME_ONE;
 626   2              SndData.DataBuf[2]  = DEVICE_NAME_TWO;
 627   2              SndData.DataBuf[3]  = DEVICE_NUM;
 628   2              SndData.DataBuf[4]  = MotorData.Mode;
 629   2              SndData.DataBuf[5]  = DisplayData.ColorValue;
 630   2              SndData.DataBuf[6]  = ChkSumH;
 631   2              SndData.DataBuf[7]  = ChkSumL;
 632   2              return;
 633   2          }
 634   1        
 635   1      
 636   1        /* CheckSum                   
 637   1         * if the command is not 0x7(set the password),
 638   1         * check the password if checksum isn't default value 0x0000
 639   1         */
 640   1        if ((RcvData.DataBuf[0]& 0x0F) != 0x7)
 641   1        {
 642   2          if ((RcvData.DataBuf[4] != ChkSumH) || (RcvData.DataBuf[5] != ChkSumL))
 643   2          {
 644   3            return;
 645   3          }
 646   2        }
 647   1        
 648   1        /* Normal Command                               */
 649   1        /* Check the Flag                               */
 650   1        /* If the command is not synchronize single     */
 651   1        if (RcvData.DataBuf[0] != 0x0F)     
 652   1        {
 653   2          if (FlagBuffer == (RcvData.DataBuf[0] >> 4))    return;
 654   2          FlagBuffer = RcvData.DataBuf[0] >> 4;
 655   2        }
 656   1        
 657   1        
 658   1        /* Received command                             *
 659   1         * FD xE 00 00 00 00 00 FE                      *
 660   1         * FD x3 MODE COLOR SPEED 00 00 FE              *
 661   1         * FD x4 HOUR 00 00 00 00                       */
 662   1        switch (RcvData.DataBuf[0] & 0x0F)
 663   1        {
 664   2          /* FD x1 00 00 00 00 00 FE        */
 665   2          /* FD x2 00 00 00 00 00 FE        */
 666   2          /* Seach Command                  */
 667   2          case 0x1:
 668   2          case 0x2:
 669   2          {
 670   3            SndData.SndStatus = SND_NORMAL;
 671   3            SndData.DataBuf[0]  = 0x01;
 672   3            SndData.DataBuf[1]  = DEVICE_NAME_ONE;
 673   3            SndData.DataBuf[2]  = DEVICE_NAME_TWO;
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 12  

 674   3            SndData.DataBuf[3]  = DEVICE_NUM;
 675   3            SndData.DataBuf[4]  = MotorData.Mode;
 676   3            SndData.DataBuf[5]  = DisplayData.ColorValue;
 677   3            SndData.DataBuf[6]  = ChkSumH;
 678   3            SndData.DataBuf[7]  = ChkSumL;
 679   3          } break;
 680   2          
 681   2          
 682   2           
 683   2          /* FD x3 MODE COLOR 00 00 00 FE   */
 684   2          /* Set the mode, color        */
 685   2          case 0x3:
 686   2          {
 687   3            // Err check
 688   3            // DisplayData.Mode     = 0x0~0xA || 0xFF
 689   3            // ColorNum   = 0x0 ~ 0x1C
 690   3            if ((RcvData.DataBuf[1] > 0x3) && (RcvData.DataBuf[1] != 0xFF))   break;
 691   3            if (RcvData.DataBuf[2] > 0x7)                   break;
 692   3             
 693   3            // Get the mode value
 694   3            DisplayData.Mode      = RcvData.DataBuf[1];
 695   3            DisplayData.InitFlag    = TRUE;
 696   3            switch (DisplayData.Mode)
 697   3            {
 698   4              case 0x0: 
 699   4              {
 700   5                          MotorData.Mode          = 0x0;
 701   5                          MotorData.InitFlag      = TRUE;
 702   5              }
 703   4              break;
 704   4              
 705   4              case 0xFF:      
 706   4              {
 707   5                DisplayData.Mode    = DisplayData.ModeBuf;
 708   5                          MotorData.Mode          = MotorData.ModeBuf;
 709   5                          MotorData.InitFlag      = TRUE;
 710   5              } break;
 711   4              
 712   4              default:      
 713   4              {
 714   5                // Get the color
 715   5                DisplayData.ColorValue    = RcvData.DataBuf[2];
 716   5                Color_Value_Get(DisplayData.ColorValue);
 717   5                 
 718   5                // Save
 719   5                DisplayData.ModeBuf     = DisplayData.Mode; 
 720   5                FlashSaveFlag       = TRUE;
 721   5                
 722   5              } break;
 723   4            }
 724   3          } break;
 725   2              
 726   2              //----------------------------------------------------------------------------
 727   2          // FD x4 MOTOR 00 00 00 00 FE
 728   2          // Set the motor speed
 729   2          case 0x4:
 730   2          {
 731   3            MotorData.ModeBuf   = RcvData.DataBuf[1];
 732   3            if (MotorData.ModeBuf > 0x2)    
 733   3                  {
 734   4                      MotorData.ModeBuf = 2;
 735   4                  }
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 13  

 736   3            MotorData.Mode    = MotorData.ModeBuf;
 737   3            MotorData.InitFlag  = TRUE;
 738   3            FlashSaveFlag       = TRUE;
 739   3          } break;
 740   2          
 741   2          
 742   2           
 743   2          //---------------------------------------------------------------------------
 744   2          // FD x5 HOUR 00 00 00 00 FE      
 745   2          // Set the timer                   
 746   2          //---------------------------------------------------------------------------
 747   2          case 0x5:
 748   2          {
 749   3            if (RcvData.DataBuf[2] > 8 || (RcvData.DataBuf[2] % 2 == 1))      break;
 750   3            TimerData.CntDwnHour    = RcvData.DataBuf[2];
 751   3            TimerData.InitFlag      = TRUE;
 752   3            FlashSaveFlag       = TRUE;
 753   3            
 754   3            DisplayData.Mode      = 0xFB;
 755   3            DisplayData.InitFlag      = TRUE;
 756   3          } break;
 757   2          
 758   2          //---------------------------------------------------------------------------
 759   2          // FD xA MODE COLOR 00 00 00 FE   
 760   2          // Set the show mode, color     
 761   2          //---------------------------------------------------------------------------
 762   2          case 0xA:
 763   2          {
 764   3            // Err check
 765   3            // DisplayData.Mode     = 0x0~0xA || 0xFF
 766   3            // ColorNum   = 0x0 ~ 0x1C
 767   3            if ((RcvData.DataBuf[1] > 0x3) || (RcvData.DataBuf[1] == 0x0))    break;
 768   3            if (RcvData.DataBuf[2] > 0x8)                                     break;
 769   3             
 770   3            // Get the mode value
 771   3            DisplayData.Mode      = RcvData.DataBuf[1] + 0xA;
 772   3            DisplayData.ModeBuf     = DisplayData.Mode;
 773   3            DisplayData.InitFlag    = TRUE;
 774   3             
 775   3            // Get the color
 776   3            DisplayData.ColorValue    = 0x7;
 777   3            Color_Value_Get(DisplayData.ColorValue);
 778   3            
 779   3            FlashSaveFlag       = TRUE;
 780   3          } break;
 781   2          
 782   2          
 783   2          
 784   2          
 785   2          //---------------------------------------------------------------------------
 786   2          // process the synchronizaton data 
 787   2          // if the device's mode or theme isn't as same as received data
 788   2          // Change the device's mode or color
 789   2          //---------------------------------------------------------------------------
 790   2          case 0xF:
 791   2          {
 792   3            if (RcvData.DataBuf[1] > 0xA && DisplayData.Mode != 0)
 793   3            {
 794   4              if (DisplayData.Mode != RcvData.DataBuf[1])
 795   4              {
 796   5                DisplayData.Mode    = RcvData.DataBuf[1];
 797   5                DisplayData.ModeBuf   = RcvData.DataBuf[1];
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 14  

 798   5                DisplayData.InitFlag  = TRUE;
 799   5                FlashSaveFlag     = TRUE;
 800   5                          DisplayData.ColorValue  = 0x7;
 801   5                Color_Value_Get(0x7);
 802   5              }
 803   4            }
 804   3          } break;
 805   2          
 806   2            
 807   2          /*
 808   2           * Password Set
 809   2           * Test -  x8 01 CRCH CRCL 00 00  --- BLUE Flash
 810   2           * Set Confirm - x8 02 CRCH CRCL 00 00, return x8 02 CRCH CRCL 
 811   2           * Set Password - x7 ID1 ID2 ID3 ID4 CHK
 812   2           * Successfully - GREEN FLASH
 813   2           */
 814   2          case 0x7:
 815   2          {
 816   3            if (PasswordFlag == TRUE)
 817   3            {
 818   4              PasswordFlag = FALSE;
 819   4              if ((RcvData.DataBuf[1] ^ RcvData.DataBuf[2] ^ RcvData.DataBuf[3] ^ RcvData.DataBuf[4]) != RcvData.Dat
             -aBuf[5])    // Password is wrong
 820   4              {
 821   5                DisplayData.Mode = 0xFF;
 822   5                DisplayData.InitFlag = TRUE;
 823   5                SndData.SndStatus   = SND_NORMAL;
 824   5                SndData.DataBuf[0]  = 0x8;
 825   5                SndData.DataBuf[1]  = 0x4;
 826   5                SndData.DataBuf[2]  = 0;
 827   5                SndData.DataBuf[3]  = 0;
 828   5                SndData.DataBuf[4]  = NewChkSumH;
 829   5                SndData.DataBuf[5]  = NewChkSumL;
 830   5                SndData.DataBuf[6]  = ChkSumH;
 831   5                SndData.DataBuf[7]  = ChkSumL;
 832   5                break;
 833   5              }
 834   4              
 835   4              ChkSumBuf = CRC16_Cal(&RcvData.DataBuf[1]);
 836   4              if (ChkSumBuf != (_Uint16)(((_Uint16)NewChkSumH << 8) + (_Uint16)NewChkSumL))
 837   4              {
 838   5                DisplayData.Mode = 0xFF;
 839   5                DisplayData.InitFlag = TRUE;        //ID1 ID2 ID3 ID4 CRC16-CCITT-FALSE  isn't equal the new checksum
 840   5                SndData.SndStatus   = SND_NORMAL;
 841   5                SndData.DataBuf[0]  = 0x8;
 842   5                SndData.DataBuf[1]  = 0x4;
 843   5                SndData.DataBuf[2]  = 0;
 844   5                SndData.DataBuf[3]  = 0;
 845   5                SndData.DataBuf[4]  = NewChkSumH;
 846   5                SndData.DataBuf[5]  = NewChkSumL;
 847   5                SndData.DataBuf[6]  = ChkSumH;
 848   5                SndData.DataBuf[7]  = ChkSumL;
 849   5                          break;
 850   5              }
 851   4              
 852   4              // Set the pass word
 853   4              ChkSumReply[0]    = Hex_To_Char(NewChkSumH >> 4);
 854   4              ChkSumReply[1]    = Hex_To_Char(NewChkSumH & 0x0F);
 855   4              ChkSumReply[2]    = Hex_To_Char(NewChkSumL >> 4);
 856   4              ChkSumReply[3]    = Hex_To_Char(NewChkSumL & 0x0F);
 857   4              SndData.SndStatus   = SND_TYPE;               // First send FC 'L' 'B' 'NUM' FE to change the broadcast name, 
             -then reply the APP
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 15  

 858   4              SndData.DataBuf[0]  = 0x8;
 859   4              SndData.DataBuf[1]  = 0x3;
 860   4              SndData.DataBuf[2]  = 0;
 861   4              SndData.DataBuf[3]  = 0;
 862   4              SndData.DataBuf[4]  = NewChkSumH;
 863   4              SndData.DataBuf[5]  = NewChkSumL;
 864   4              SndData.DataBuf[6]  = ChkSumH;
 865   4              SndData.DataBuf[7]  = ChkSumL;
 866   4              ChkSumH       = NewChkSumH;
 867   4              ChkSumL       = NewChkSumL;
 868   4              NewChkSumH      = 0;
 869   4              NewChkSumL      = 0;
 870   4              
 871   4              DisplayData.Mode      = 0xFD;
 872   4              DisplayData.InitFlag  = TRUE;
 873   4              FlashSaveFlag     = TRUE;
 874   4            }
 875   3            
 876   3            // time out
 877   3            else
 878   3            {
 879   4              SndData.SndStatus   = SND_NORMAL;
 880   4              SndData.DataBuf[0]  = 0x8;
 881   4              SndData.DataBuf[1]  = 0x4;
 882   4              SndData.DataBuf[2]  = 0;
 883   4              SndData.DataBuf[3]  = 0;
 884   4              SndData.DataBuf[4]  = NewChkSumH;
 885   4              SndData.DataBuf[5]  = NewChkSumL;
 886   4              SndData.DataBuf[6]  = ChkSumH;
 887   4              SndData.DataBuf[7]  = ChkSumL;
 888   4            }
 889   3          } break;
 890   2          
 891   2          case 0x8:
 892   2          {
 893   3            if (RcvData.DataBuf[1] == 0x1)
 894   3            {
 895   4              DisplayData.Mode    = 0xFB;
 896   4              DisplayData.InitFlag  = TRUE;
 897   4            }
 898   3            else if (RcvData.DataBuf[1] == 0x2)
 899   3            {
 900   4              PasswordFlag = TRUE;                // Allow set the password within 5 seconds
 901   4              
 902   4              NewChkSumH = RcvData.DataBuf[2];
 903   4              NewChkSumL = RcvData.DataBuf[3];
 904   4              SndData.SndStatus   = SND_NORMAL;
 905   4              SndData.DataBuf[0]  = RcvData.DataBuf[0];
 906   4              SndData.DataBuf[1]  = 0x2;
 907   4              SndData.DataBuf[2]  = 0;
 908   4              SndData.DataBuf[3]  = 0;
 909   4              SndData.DataBuf[4]  = NewChkSumH;
 910   4              SndData.DataBuf[5]  = NewChkSumL;
 911   4              SndData.DataBuf[6]  = ChkSumH;
 912   4              SndData.DataBuf[7]  = ChkSumL;
 913   4            }
 914   3          } break;
 915   2          
 916   2          
 917   2          /*
 918   2           * TEST command 1,2...
 919   2           * xD 00 00 00 00 00
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 16  

 920   2           * xD 01 00 00 00 00
 921   2           * Reply the equipment type and HSE status, version number...
 922   2           */
 923   2          case 0xD:
 924   2          {
 925   3            if (RcvData.DataBuf[1] == 0x0)
 926   3            {
 927   4              SndData.SndStatus   = SND_NORMAL;
 928   4              SndData.DataBuf[0]  = 0xD;
 929   4              SndData.DataBuf[1]  = DEVICE_NAME_ONE;
 930   4              SndData.DataBuf[2]  = DEVICE_NAME_TWO;
 931   4              SndData.DataBuf[3]  = DEVICE_NUM;
 932   4              SndData.DataBuf[4]  = 0;      
 933   4              SndData.DataBuf[5]  = TimerData.CntDwnHour;
 934   4              SndData.DataBuf[6]  = ChkSumH;
 935   4              SndData.DataBuf[7]  = ChkSumL;
 936   4              break;
 937   4            }
 938   3            
 939   3            if (RcvData.DataBuf[1] == 0x1)
 940   3            {
 941   4              SndData.SndStatus   = SND_NORMAL;
 942   4              SndData.DataBuf[0]  = 0xD;
 943   4              SndData.DataBuf[1]  = HseStatus;              // HSE status
 944   4              SndData.DataBuf[2]  = 0;              // Watch Dog status
 945   4              SndData.DataBuf[3]  = PROTOCOL_VER;               // Protocol version
 946   4              SndData.DataBuf[4]  = SOFT_VER;               // Software version
 947   4              SndData.DataBuf[5]  = 0x18;                 // Year 2018                  
 948   4              SndData.DataBuf[6]  = 'W';                  // Company Willis Co.
 949   4              SndData.DataBuf[7]  = 'C';                  // Author DS.Chin(James.Chin or Jim.C)
 950   4            }
 951   3          } break;
 952   2        }
 953   1      }
 954          
 955          
 956          /*******************************************************************************
 957            *
 958            * FunctionName    CRC16_Cal
 959            *
 960          ********************************************************************************/
 961          _Uint16 CRC16_Cal(_Uint8 Buffer[])
 962          {
 963   1        _Uint16   ResultBuf   = 0x0000;
 964   1        _Uint8    CntBuf      = 0;
 965   1        _Uint8    BitBuf      = 0;
 966   1        
 967   1        for (CntBuf = 0; CntBuf < 4; CntBuf++)
 968   1        {
 969   2          ResultBuf ^= ((_Uint16)Buffer[CntBuf] << 8);
 970   2          
 971   2          for (BitBuf = 0; BitBuf < 8; BitBuf++)
 972   2          {
 973   3            if ((ResultBuf & 0x8000) == 0x8000)
 974   3            {
 975   4              ResultBuf = (ResultBuf << 1) ^ 0x1021;
 976   4            }
 977   3            else
 978   3            {
 979   4              ResultBuf <<= 1;
 980   4            }
 981   3          }
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 17  

 982   2        }
 983   1        
 984   1        return ResultBuf;
 985   1      }
 986          
 987          /****************************************************************************
 988           * Color_Value_Get
 989           */
 990          void Color_Value_Get(_Uint8 ColorNumBuf)
 991          {
 992   1        _Uint8  TempCnt = 0;
 993   1        
 994   1        if (DisplayData.Mode > 0xA)
 995   1        {
 996   2          for (TempCnt = 0; TempCnt < 7; TempCnt++)
 997   2          {
 998   3            ColorData[TempCnt][0] = COLOR_VECTOR[TempCnt + 1][0];
 999   3            ColorData[TempCnt][1] = COLOR_VECTOR[TempCnt + 1][1];
1000   3            ColorData[TempCnt][2] = COLOR_VECTOR[TempCnt + 1][2];
1001   3          }
1002   2        }
1003   1        else
1004   1        {
1005   2          ColorData[0][0] = COLOR_VECTOR[ColorNumBuf][0];
1006   2          ColorData[0][1] = COLOR_VECTOR[ColorNumBuf][1];
1007   2          ColorData[0][2] = COLOR_VECTOR[ColorNumBuf][2];
1008   2        }
1009   1      }
1010          
1011          
1012          
1013          
1014          
1015          
1016          /************************************************************************
1017           *
1018           * FunctionName   Hex_To_Char
1019           *
1020           *  Input          HexBuf
1021           *                 HexBuf < 0x10
1022          *************************************************************************/
1023          static _Uint8   Hex_To_Char(_Uint8 HexBuf)
1024          {
1025   1        if (HexBuf > 0x0F)    HexBuf &= 0x0F;
1026   1        
1027   1        //Hex = 0x0,0x1...0x9
1028   1        if (HexBuf < 0xA) 
1029   1        {
1030   2          return (HexBuf + '0');
1031   2        }
1032   1        
1033   1        // Hex = 0xA,0xB ... 0xF
1034   1        HexBuf -= 0xA;
1035   1        return (HexBuf + 'A');
1036   1      }
1037          
1038          
1039          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1737    ----
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/30/2018 19:49:13 PAGE 18  

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29       7
   IDATA SIZE       =     18    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
