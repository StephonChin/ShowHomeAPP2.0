C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE DATA_PROCESS
OBJECT MODULE PLACED IN Data_Process.obj
COMPILER INVOKED BY: C:\Keil\C51\C51\BIN\C51.EXE PublicSrc\Data_Process.c BROWSE INCDIR(.\PrivateInc;.\PublicInc) DEBUG 
                    -OBJECTEXTEND PRINT(.\Data_Process.lst) OBJECT(Data_Process.obj)

line level    source

   1          /*******************************************************************************
   2                  *
   3                  * FILE NAME
   4                  *                                               Data_Process.c
   5                  *
   6                  * NODE
   7                  *                                               About horse run mode
   8                  *                                                       if the mode is run mode, ripple mode, flower bloom mode, polar light mode, color show mode,
   9                  *                                                       only AL91 or AL94 have horse function.
  10                  *
  11                  *                                                       if the mode is show1, show2, or show3
  12                  *                                                       all the product have horse function.
  13                  *
  14          *******************************************************************************/
  15          #include "Data_Process.h"
  16          
  17          //----------------------------------------------------------------------------
  18          // Gloable Parameters
  19          //----------------------------------------------------------------------------
  20          idata _Uint8                                    ChkSumH;
  21          idata _Uint8                                    ChkSumL;
  22          idata _Uint8                                    ChkSumRst;
  23          idata _Uint8                                    ChkSumRstSave;
  24          idata _Uint8                                    PowerOnNum;
  25          
  26          
  27          
  28          
  29          //----------------------------------------------------------------------------
  30          // File Parameters
  31          //----------------------------------------------------------------------------
  32          idata _Uint8                                    NewChkSumH;
  33          idata _Uint8                                    NewChkSumL;
  34          idata _Uint8                                    ChkSumRstTime;
  35          idata _Flag                                         PasswordFlag;                                               //Allow set the password flag
  36          idata _Flag                                         SynRcvFlag;
  37          idata _Uint8                                    FlagChkTime;
  38          idata _Flag                                         FlagChkFlag;
  39          
  40          idata _Uint8                    NtcBanTime[2];
  41          idata _Flag                             NtcBanFlag;
  42          idata _Flag                             NtcBanInit;
  43          
  44          
  45          
  46          
  47          
  48          
  49          /******************************************************************************
  50                  *
  51                  * COLOR_TABLE
  52                  *
  53                  * DESCRIPTION
  54                  *                                                               Color value combine with R value, G value and B value,
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 2   

  55                  *                                                               or  with R value, G value , B value and W value
  56                  *
  57          *******************************************************************************/
  58          const _Uint8 COLOR_VECTOR[8][3] =
  59          {
  60                  100,            0,                      0,
  61              100,                0,                      0,                              //1:red
  62              0,                  100,            0,                              //2:green 
  63                  100,            100,            0,                              //3:r g
  64              0,                  0,                      100,                            //4:blue
  65              100,                0,                      100,                            //5:r b
  66              0,                  100,            100,                            //6:g b
  67              100,                100,            100                             //7:r g b
  68          };
  69          
  70          
  71          
  72          /************************************************************************************
  73                  *
  74                  * FUNCTION NAME         |       User_Data_Init
  75                  * INPUT                     |   None
  76                  * OUTPUT                        |       None
  77                  * BRIEF                         |       Initialize the user data after power on, include display
  78                  *                                               mode, color theme, time count down hour and others
  79                  *
  80          *************************************************************************************/
  81          void User_Data_Init(void)
  82          {
  83   1              //-----------------------------------------------------------------
  84   1              // if the first time to power on
  85   1              //-----------------------------------------------------------------
  86   1          PowerOnNum = Byte_Read_From_APROM(APROM_POWER_ON_NUM);
  87   1              if (PowerOnNum != 0xAA)
  88   1              {
  89   2                      DisplayData.ModeBuf             = 0x1;
  90   2                      DisplayData.ColorValue          = 0x7;
  91   2                      TimerData.CntDwnHour            = 0x6;
  92   2              MotorData.ModeBuf           = 0x1;
  93   2                      ChkSumH                                         = 0;
  94   2                      ChkSumL                                         = 0;
  95   2                      ChkSumReply[0]                          = '0';
  96   2                      ChkSumReply[1]                          = '0';
  97   2                      ChkSumReply[2]                          = '0';
  98   2                      ChkSumReply[3]                          = '0';
  99   2                      ChkSumRst                                       = 0;
 100   2                      PowerOnNum                                      = 0xAA;
 101   2                      ChkSumRstSave                           = 0;
 102   2                      FlashSaveFlag                           = TRUE;
 103   2                      
 104   2                      DisplayData.Mode                        = 0x1;
 105   2                      DisplayData.InitFlag            = TRUE;
 106   2              MotorData.Mode              = 0x1;
 107   2              MotorData.InitFlag          = TRUE;
 108   2              TimerData.InitFlag              = TRUE;
 109   2                      Color_Value_Get(DisplayData.ColorValue);
 110   2                      return;
 111   2              }
 112   1              
 113   1              //-----------------------------------------------------------------
 114   1              // Get the mode from eprom after power on
 115   1              // When display mode equl 0 (means turn off all leds, then set
 116   1              // the mode to 0xA (color show), and save it to eprom
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 3   

 117   1              //-----------------------------------------------------------------
 118   1          DisplayData.ModeBuf = Byte_Read_From_APROM(APROM_MODE);
 119   1              if (DisplayData.ModeBuf == 0 || (DisplayData.ModeBuf > 0x3 && DisplayData.ModeBuf < 0xB) || DisplayData.M
             -odeBuf > 0xD)
 120   1              {
 121   2                      DisplayData.ModeBuf     = 0x1;
 122   2                      FlashSaveFlag                   = TRUE;
 123   2              }
 124   1              DisplayData.Mode                        = DisplayData.ModeBuf;
 125   1              DisplayData.InitFlag            = TRUE;
 126   1              
 127   1              
 128   1              //---------------------------------------------------------------------
 129   1              // Get the color value from eprom after power on
 130   1              // When the color value is more than the COLOR_MAX, set it to COLOR_MAX
 131   1              // and save the value to eprom 
 132   1              //----------------------------------------------------------------------
 133   1          DisplayData.ColorValue  = Byte_Read_From_APROM(APROM_COLOR);
 134   1              if (DisplayData.ColorValue > COLOR_MAX)
 135   1              {
 136   2                      DisplayData.ColorValue  = COLOR_MAX;
 137   2                      FlashSaveFlag                   = TRUE;
 138   2              }
 139   1              Color_Value_Get(DisplayData.ColorValue);
 140   1              
 141   1              
 142   1              //----------------------------------------------------------------------
 143   1              // Get the count down hour from eprom after power on,
 144   1              // if valid value is more than 8 , seit it to 6,
 145   1              // and save6 to eprom
 146   1              // Set the OnOffFlag
 147   1              //----------------------------------------------------------------------
 148   1          TimerData.CntDwnHour = Byte_Read_From_APROM(APROM_CNTDWN_HOUR);
 149   1              if (TimerData.CntDwnHour > 8 || (TimerData.CntDwnHour % 2 == 1))
 150   1              {
 151   2                      TimerData.CntDwnHour    = 6;
 152   2                      FlashSaveFlag                   = TRUE;
 153   2              }
 154   1              TimerData.InitFlag      = TRUE;
 155   1              TimerData.OnOffFlag = TRUE;
 156   1              
 157   1              
 158   1              
 159   1          
 160   1          //-------------------------------------------------------------------------
 161   1              // Get the motor value from eprom
 162   1          //-------------------------------------------------------------------------
 163   1              MotorData.ModeBuf       = Byte_Read_From_APROM(APROM_MOTOR);
 164   1              if (MotorData.ModeBuf > 2)
 165   1              {
 166   2                      MotorData.ModeBuf   = 1;
 167   2                      FlashSaveFlag       = TRUE;
 168   2              }
 169   1              MotorData.Mode                  = MotorData.ModeBuf;
 170   1              MotorData.InitFlag              = TRUE;
 171   1              
 172   1      
 173   1                      
 174   1                      
 175   1          //----------------------------------------------------------------------
 176   1          // Check the count
 177   1          // if power on 3 times in 5 seconds, reset the checksum
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 4   

 178   1          // 1 -> write 0x55
 179   1          // 2 -> write 0xAA
 180   1          // 3 -> Reset
 181   1          //----------------------------------------------------------------------
 182   1          ChkSumRst   = Byte_Read_From_APROM(APROM_CHK_RST_CNT);
 183   1          ChkSumH     = Byte_Read_From_APROM(APROM_CHKSUM_H);
 184   1          ChkSumL     = Byte_Read_From_APROM(APROM_CHKSUM_L);
 185   1          if (ChkSumRst == 0)
 186   1          {
 187   2              ChkSumRstSave           = 0x55;
 188   2              FlashSaveFlag           = TRUE;
 189   2          }
 190   1          else if (ChkSumRst == 0x55)
 191   1          {
 192   2              ChkSumRstSave           = 0xAA;
 193   2              FlashSaveFlag           = TRUE;
 194   2          }
 195   1          else if (ChkSumRst == 0xAA)
 196   1          {
 197   2              ChkSumH                         = 0;
 198   2              ChkSumL                         = 0;
 199   2              ChkSumRstSave = 0;
 200   2              ChkSumRst                       = 0;
 201   2              FlashSaveFlag = TRUE;
 202   2              
 203   2              DisplayData.Mode            = 0xFD;
 204   2              DisplayData.InitFlag    = TRUE;
 205   2          }
 206   1          
 207   1          ChkSumReply[0] = Hex_To_Char(ChkSumH >> 4);
 208   1          ChkSumReply[1] = Hex_To_Char(ChkSumH & 0x0F);
 209   1          ChkSumReply[2] = Hex_To_Char(ChkSumL >> 4);
 210   1          ChkSumReply[3] = Hex_To_Char(ChkSumL & 0x0F);       
 211   1      }
 212          
 213          
 214          
 215          /*************************************************************************************
 216                  *
 217                  * FUNCTION NAME         |       Data_Process
 218                  * INPUT                                         |       None
 219                  * OUTPUT                                        |       None
 220                  * DESCRIPTION                   |       Process all the data here. change the mode , color, timer or
 221                  *                                                                               other parameters after received valid data from CSR1010
 222                  *
 223          ***************************************************************************************/
 224          void Data_Process(void)
 225          {
 226   1              /* Key Process */
 227   1              Key_Process();
 228   1          
 229   1          /* Detect the temperature */
 230   1          Tmprtr_Process();
 231   1              
 232   1              /* Timer Process */
 233   1              Count_Down_Process();
 234   1              
 235   1              /* Password Process */
 236   1              Password_Process();
 237   1              
 238   1              /* Synchronize Process */
 239   1              Syn_Process();
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 5   

 240   1              
 241   1              /* CSR1010 Process */
 242   1              CSR1010_Process();
 243   1      }
 244          
 245          /************************************************************
 246                  *
 247                  * @FunctonName  Key_Process
 248                  * @Brief                Process the key
 249                  *                               Change the color and mode after short key
 250                  */
 251          static void Key_Process(void)
 252          {
 253   1              //------------------------------------------------------
 254   1              // When key status is idle, return
 255   1              //------------------------------------------------------
 256   1              if (KeyStatus == KEY_IDLE)              return;
 257   1      
 258   1              
 259   1              //-------------------------------------------------------
 260   1              // Short Press
 261   1              //-------------------------------------------------------
 262   1              if (KeyStatus == KEY_SHORT)
 263   1              {
 264   2                      //Temperature Ban
 265   2                      NtcBanFlag = TRUE;
 266   2                      NtcBanInit = TRUE;
 267   2                      
 268   2                      //clear the status
 269   2                      KeyStatus = KEY_IDLE;
 270   2                      
 271   2                      //set data intialize flag
 272   2                      DisplayData.InitFlag    = TRUE;
 273   2                      
 274   2                      // power on
 275   2                      if (DisplayData.Mode == 0)
 276   2                      {
 277   3                              DisplayData.Mode                = DisplayData.ModeBuf;
 278   3                              MotorData.Mode                  = MotorData.ModeBuf;
 279   3                              MotorData.InitFlag          = TRUE;
 280   3                              
 281   3                              if (DisplayData.ColorValue == 0x0 || DisplayData.ColorValue > 0x7)
 282   3                              {
 283   4                                      DisplayData.ColorValue  = 0x7;
 284   4                                      FlashSaveFlag           = TRUE;
 285   4                              }
 286   3                              Color_Value_Get(DisplayData.ColorValue);        
 287   3                      }
 288   2                      
 289   2                      
 290   2              else if (DisplayData.Mode > 0xA)
 291   2              {
 292   3                  DisplayData.ModeBuf++;
 293   3                  DisplayData.Mode = DisplayData.ModeBuf;
 294   3                  if (DisplayData.ModeBuf > 0xD)
 295   3                  {
 296   4                      DisplayData.Mode            = 0;
 297   4                      MotorData.Mode              = 0;
 298   4                      MotorData.InitFlag          = TRUE;
 299   4                      DisplayData.ModeBuf         = 1;
 300   4                      DisplayData.ColorValue      = 1;
 301   4                  }
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 6   

 302   3                  FlashSaveFlag                   = TRUE;
 303   3              }
 304   2              
 305   2              // change thecolor
 306   2                      else
 307   2                      {       
 308   3                              // change color
 309   3                  DisplayData.ModeBuf = 1;
 310   3                              DisplayData.ColorValue++;
 311   3                              if (DisplayData.ColorValue > COLOR_MAX)
 312   3                              {
 313   4                                      DisplayData.ColorValue = 0x1;
 314   4                                      DisplayData.ModeBuf = 0xB;
 315   4                              }
 316   3                  DisplayData.Mode    = DisplayData.ModeBuf;
 317   3                              FlashSaveFlag       = TRUE;
 318   3                      }
 319   2              
 320   2                      Color_Value_Get(DisplayData.ColorValue);
 321   2              }
 322   1              
 323   1              //long press to power off
 324   1              else
 325   1              if (KeyStatus == KEY_LONG)
 326   1              {
 327   2                      KeyStatus       = KEY_IDLE;
 328   2                      if (DisplayData.Mode != 0)
 329   2                      {
 330   3                              DisplayData.Mode                = 0;
 331   3                              DisplayData.InitFlag    = TRUE;
 332   3                              MotorData.Mode                  = 0;
 333   3                              MotorData.InitFlag              = TRUE;
 334   3                      }
 335   2              }
 336   1      }
 337          
 338          
 339          
 340          /**********************************************************************************
 341                  *
 342                  * FUNCTIONNAME                  | Tmprtr_Process
 343                  *       INPUT                                                   | None
 344                  * OUTPUT                                                | None
 345                  * DESCRIPTION                           | Detect the environment temperature
 346          ************************************************************************************/
 347          static void Tmprtr_Process(void)
 348          {
 349   1              //-------------------------------------------------------
 350   1              // The Temperature is less than 55
 351   1              //-------------------------------------------------------
 352   1              if (NtcStatus == NTC_IDLE || NtcStatus == NTC_HOT)
 353   1              {
 354   2                      NtcBanTime[0] = 0;
 355   2                      NtcBanTime[1] = 0;
 356   2                      NtcBanFlag        = FALSE;
 357   2                      return;
 358   2              }
 359   1              
 360   1              //-------------------------------------------------------
 361   1              // The Temperature is greater than 55 
 362   1              //-------------------------------------------------------
 363   1              if (NtcStatus == NTC_BAN)
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 7   

 364   1              {
 365   2                      if (NtcBanFlag == TRUE)
 366   2                      {
 367   3                              if (NtcBanInit == TRUE)
 368   3                              {
 369   4                                      NtcBanInit = FALSE;
 370   4                                      NtcBanTime[0] = 0;
 371   4                                      NtcBanTime[1] = 0;
 372   4                              }
 373   3                              
 374   3                              NtcBanTime[0]++;
 375   3                              if (NtcBanTime[0] >= 50) //1s
 376   3                              {
 377   4                                      NtcBanTime[0] = 0;
 378   4                                      NtcBanTime[1]++;
 379   4                                      if (NtcBanTime[1] >= 20) //20s
 380   4                                      {
 381   5                                              NtcBanTime[1] = 0;
 382   5                                              NtcBanFlag = FALSE;
 383   5                                      }
 384   4                              }
 385   3                      }
 386   2                      
 387   2                      //-----------------------------------------------------
 388   2                      // after 20 seconds, turn off the LED & Motor
 389   2                      //-----------------------------------------------------
 390   2                      else
 391   2                      {
 392   3                              DisplayData.Mode                = 0;
 393   3                              DisplayData.InitFlag    = TRUE;
 394   3                              MotorData.Mode                  = 0;
 395   3                              MotorData.InitFlag              = TRUE;
 396   3                      }
 397   2              }
 398   1              
 399   1              //------------------------------------------------------
 400   1              // When Temperature is less than 50 after 1h
 401   1              //------------------------------------------------------
 402   1              if (NtcStatus == NTC_BAN_EXIT)
 403   1              {
 404   2                      NtcStatus = NTC_IDLE;
 405   2                      //restore the Led & Motor work mode
 406   2                      if (TimerData.OnOffFlag == TRUE)
 407   2                      {
 408   3                              DisplayData.Mode                = DisplayData.ModeBuf;
 409   3                              DisplayData.InitFlag    = TRUE;
 410   3                              MotorData.Mode                  = MotorData.ModeBuf;
 411   3                              MotorData.InitFlag              = TRUE;
 412   3                      }
 413   2              }
 414   1      }
 415          
 416          
 417          
 418          
 419          /************************************************************
 420                  *
 421                  * @FunctonName  Password_Process
 422                  *
 423          *****/
 424          static void Password_Process(void)
 425          {
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 8   

 426   1              static  _Uint8                  PasswordTime;   
 427   1              
 428   1              // Reset checksum time caculate
 429   1              if (ChkSumRst != 0)
 430   1              {
 431   2                      ChkSumRstTime++;
 432   2                      if (ChkSumRstTime >= 250)
 433   2                      {
 434   3                              ChkSumRstTime = 0;
 435   3                              ChkSumRst               = 0;
 436   3                              ChkSumRstSave   = 0;
 437   3                              FlashSaveFlag = TRUE;
 438   3                      }
 439   2              }
 440   1              
 441   1              
 442   1              //----------------------------------------------------------------------------------------
 443   1              // About Password Set
 444   1              //
 445   1              // * When received the single that allow set the password, then caculate 5 seconds
 446   1              //   if haven't received any password, reset the allow flag
 447   1              //-----------------------------------------------------------------------------------------
 448   1              if (PasswordFlag)
 449   1              {
 450   2                      PasswordTime++;
 451   2                      if (PasswordTime >= 250)                                PasswordFlag = FALSE;
 452   2              }
 453   1              else
 454   1              {
 455   2                      PasswordTime = 0;
 456   2              }
 457   1      }
 458          
 459          
 460          /****************************************************************************
 461           *
 462           * @FunctonName Syn_Process
 463           * if SynRcvFlag is TRUE(when received synchronize single),
 464             the next 3 seconds do not allowed to receive the same command
 465           
 466           * if the flag of synchronization is true, send data mode + serias + checksum
 467          
 468           * SynData[2] used for horse mode under AL91 or AL94
 469           *
 470          ******************************************************************************/
 471          static void Syn_Process(void)
 472          {
 473   1                      static  _Uint8                  SynRcvTime      = 0;
 474   1              
 475   1              //-------------------------------------------------------------------------------------
 476   1              // About synchronizing single
 477   1              //
 478   1              
 479   1              //--------------------------------------------------------------------------------------
 480   1              if (SynRcvFlag == TRUE)
 481   1              {
 482   2                      SynRcvTime++;
 483   2                      if (SynRcvTime > 150)
 484   2                      {
 485   3                              SynRcvTime = 0;
 486   3                              SynRcvFlag = FALSE;
 487   3                      }
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 9   

 488   2              }
 489   1              else
 490   1              {
 491   2                      SynRcvTime = 0;
 492   2              }
 493   1      }
 494          
 495          
 496          
 497          /************************************************************
 498                  *
 499                  * @FunctonName  Count_Down_Process
 500                  *
 501          *****/
 502          static void Count_Down_Process(void)
 503          {
 504   1              /* When TimerData.Status equals TIM_IDLE, exit this function */
 505   1              if (TimerData.Status == TIM_IDLE)       return;
 506   1              
 507   1              /* Open */
 508   1              if (TimerData.Status == TIM_OPEN)       
 509   1              {
 510   2                      TimerData.Status                = TIM_IDLE;
 511   2                      DisplayData.Mode                = DisplayData.ModeBuf;
 512   2                      DisplayData.InitFlag    = TRUE;
 513   2              
 514   2              MotorData.Mode          = MotorData.ModeBuf;
 515   2              MotorData.InitFlag      = TRUE;
 516   2                      return;
 517   2              }
 518   1              
 519   1              /* Close */
 520   1              if (TimerData.Status == TIM_CLOSE)
 521   1              {
 522   2                      TimerData.Status            = TIM_IDLE;
 523   2                      DisplayData.Mode                = 0x0;
 524   2                      DisplayData.InitFlag    = TRUE;
 525   2              
 526   2              MotorData.Mode          = 0;
 527   2              MotorData.InitFlag      = TRUE;
 528   2                      return;
 529   2              }
 530   1      }
 531          
 532          
 533          /****************************************************************************************
 534                  *
 535                  * FUNCTIONNAME          | CSR1010_Process
 536                  * INPUT                     | None
 537                  * OUTPUT                        | None
 538                  * DESCRIPTION           | Send data to or received data from CSR1010
 539                  *
 540          *****************************************************************************************/
 541          static void CSR1010_Process(void)
 542          {
 543   1              static  _Uint8          TypeReplyTime;
 544   1              static  _Flag       BtInitFlag;         //bluetooth intialization' flag
 545   1              static  _Uint8          FlagBuffer      = 0xFF;
 546   1                              _Uint16         ChkSumBuf = 0;
 547   1                      
 548   1              
 549   1              //----------------------------------------------------------------------
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 10  

 550   1              // if device haven't received command FD F0 FE within 1 second after power on,
 551   1              // send the type to CSR1010
 552   1              //-----------------------------------------------------------------------
 553   1              if (BtInitFlag == FALSE)
 554   1              {
 555   2                      TypeReplyTime++;
 556   2                      if (TypeReplyTime >= 50)
 557   2                      {
 558   3                              BtInitFlag                      = TRUE;              
 559   3                              SndData.SndStatus       = SND_TYPE;
 560   3                              SndData.DataBuf[0]      = 0x01;
 561   3                              SndData.DataBuf[1]      = DEVICE_NAME_ONE;
 562   3                              SndData.DataBuf[2]      = DEVICE_NAME_TWO;
 563   3                              SndData.DataBuf[3]      = DEVICE_NUM;
 564   3                              SndData.DataBuf[4]  = MotorData.Mode;
 565   3                              SndData.DataBuf[5]  = DisplayData.ColorValue;
 566   3                              SndData.DataBuf[6]      = ChkSumH;
 567   3                              SndData.DataBuf[7]      = ChkSumL;
 568   3                      }
 569   2              }
 570   1              
 571   1              
 572   1              
 573   1              //-----------------------------------------------------------------------
 574   1              // if device haven't received any command within 500ms,
 575   1              // clear the flagstatus
 576   1              //-----------------------------------------------------------------------
 577   1              if (FlagChkFlag)
 578   1              {
 579   2                      FlagChkTime++;
 580   2                      if (FlagChkTime >= 25)
 581   2                      {
 582   3                              FlagChkTime     = 0;
 583   3                              FlagBuffer              = 0xFF;
 584   3                              FlagChkFlag     = FALSE;
 585   3                      }
 586   2              }
 587   1              
 588   1      
 589   1              
 590   1              /* Check the received flag, when it is false, return */
 591   1              if (RcvFlag == FALSE)           return;
 592   1              
 593   1              
 594   1              /* Received the command from CSR1010
 595   1               * Clear the received flag                              
 596   1               */
 597   1              RcvFlag                         = FALSE;
 598   1              FlagChkFlag             = TRUE;
 599   1              FlagChkTime             = 0;
 600   1              
 601   1              
 602   1              /* CSR1010 Initialize                                   */
 603   1              if (BtInitFlag == FALSE)
 604   1              {
 605   2                      if (RcvData.DataBuf[0] == 0xF0)
 606   2                      {
 607   3                              BtInitFlag                      = TRUE;              
 608   3                              SndData.SndStatus       = SND_TYPE;
 609   3                              SndData.DataBuf[0]      = 0x01;
 610   3                              SndData.DataBuf[1]      = DEVICE_NAME_ONE;
 611   3                              SndData.DataBuf[2]      = DEVICE_NAME_TWO;
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 11  

 612   3                              SndData.DataBuf[3]      = DEVICE_NUM;
 613   3                              SndData.DataBuf[4]  = MotorData.Mode;
 614   3                              SndData.DataBuf[5]  = DisplayData.ColorValue;
 615   3                              SndData.DataBuf[6]      = ChkSumH;
 616   3                              SndData.DataBuf[7]      = ChkSumL;
 617   3                              return;
 618   3                      }
 619   2              }
 620   1              
 621   1      
 622   1              /* CheckSum                                                                     
 623   1               * if the command is not 0x7(set the password),
 624   1               * check the password if checksum isn't default value 0x0000
 625   1               */
 626   1              if ((RcvData.DataBuf[0]& 0x0F) != 0x7)
 627   1              {
 628   2                      if ((RcvData.DataBuf[4] != ChkSumH) || (RcvData.DataBuf[5] != ChkSumL))
 629   2                      {
 630   3                              return;
 631   3                      }
 632   2              }
 633   1              
 634   1              /* Normal Command                                                                                                                       */
 635   1              /* Check the Flag                               */
 636   1              /* If the command is not synchronize single                     */
 637   1              if (RcvData.DataBuf[0] != 0x0F)                 
 638   1              {
 639   2                      if (FlagBuffer == (RcvData.DataBuf[0] >> 4))            return;
 640   2                      FlagBuffer = RcvData.DataBuf[0] >> 4;
 641   2              }
 642   1              
 643   1              
 644   1              /* Received command                                                                                                                     *
 645   1               * FD xE 00 00 00 00 00 FE                                                                                      *
 646   1               * FD x3 MODE COLOR SPEED 00 00 FE              *
 647   1               * FD x4 HOUR 00 00 00 00                       */
 648   1              switch (RcvData.DataBuf[0] & 0x0F)
 649   1              {
 650   2                      /* FD x1 00 00 00 00 00 FE                              */
 651   2                      /* FD x2 00 00 00 00 00 FE                              */
 652   2                      /* Seach Command                                                                        */
 653   2                      case 0x1:
 654   2                      case 0x2:
 655   2                      {
 656   3                              SndData.SndStatus       = SND_NORMAL;
 657   3                              SndData.DataBuf[0]      = 0x01;
 658   3                              SndData.DataBuf[1]      = DEVICE_NAME_ONE;
 659   3                              SndData.DataBuf[2]      = DEVICE_NAME_TWO;
 660   3                              SndData.DataBuf[3]      = DEVICE_NUM;
 661   3                              SndData.DataBuf[4]  = MotorData.Mode;
 662   3                              SndData.DataBuf[5]  = DisplayData.ColorValue;
 663   3                              SndData.DataBuf[6]      = ChkSumH;
 664   3                              SndData.DataBuf[7]      = ChkSumL;
 665   3                      } break;
 666   2                      
 667   2                      
 668   2                       
 669   2                      /* FD x3 MODE COLOR 00 00 00 FE         */
 670   2                      /* Set the mode, color                          */
 671   2                      case 0x3:
 672   2                      {
 673   3                              // Err check
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 12  

 674   3                              // DisplayData.Mode             = 0x0~0xA || 0xFF
 675   3                              // ColorNum             = 0x0 ~ 0x1C
 676   3                              if ((RcvData.DataBuf[1] > 0x3) && (RcvData.DataBuf[1] != 0xFF))         break;
 677   3                              if (RcvData.DataBuf[2] > 0x7)                                                                           break;
 678   3                               
 679   3                              // Get the mode value
 680   3                              DisplayData.Mode                        = RcvData.DataBuf[1];
 681   3                              DisplayData.InitFlag            = TRUE;
 682   3                              switch (DisplayData.Mode)
 683   3                              {
 684   4                                      case 0x0:       
 685   4                                      {
 686   5                          MotorData.Mode          = 0x0;
 687   5                          MotorData.InitFlag      = TRUE;
 688   5                                      }
 689   4                                      break;
 690   4                                      
 691   4                                      case 0xFF:                      
 692   4                                      {
 693   5                                              DisplayData.Mode                = DisplayData.ModeBuf;
 694   5                          MotorData.Mode          = MotorData.ModeBuf;
 695   5                          MotorData.InitFlag      = TRUE;
 696   5                                      } break;
 697   4                                      
 698   4                                      default:                        
 699   4                                      {
 700   5                                              // Get the color
 701   5                                              DisplayData.ColorValue          = RcvData.DataBuf[2];
 702   5                                              Color_Value_Get(DisplayData.ColorValue);
 703   5                                               
 704   5                                              // Save
 705   5                                              DisplayData.ModeBuf             = DisplayData.Mode;     
 706   5                                              FlashSaveFlag                           = TRUE;
 707   5                                              
 708   5                                      } break;
 709   4                              }
 710   3                      } break;
 711   2              
 712   2              //----------------------------------------------------------------------------
 713   2                      // FD x4 MOTOR 00 00 00 00 FE
 714   2                      // Set the motor speed
 715   2                      case 0x4:
 716   2                      {
 717   3                              MotorData.ModeBuf       = RcvData.DataBuf[1];
 718   3                              if (MotorData.ModeBuf > 0x2)            
 719   3                  {
 720   4                      MotorData.ModeBuf = 2;
 721   4                  }
 722   3                              MotorData.Mode          = MotorData.ModeBuf;
 723   3                              MotorData.InitFlag      = TRUE;
 724   3                              FlashSaveFlag       = TRUE;
 725   3                      } break;
 726   2                      
 727   2                      
 728   2                       
 729   2                      //---------------------------------------------------------------------------
 730   2                      // FD x5 HOUR 00 00 00 00 FE      
 731   2                      // Set the timer                   
 732   2                      //---------------------------------------------------------------------------
 733   2                      case 0x5:
 734   2                      {
 735   3                              if (RcvData.DataBuf[2] > 8 || (RcvData.DataBuf[2] % 2 == 1))                    break;
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 13  

 736   3                              TimerData.CntDwnHour            = RcvData.DataBuf[2];
 737   3                              TimerData.InitFlag                      = TRUE;
 738   3                              FlashSaveFlag                           = TRUE;
 739   3                              
 740   3                              DisplayData.Mode                        = 0xFB;
 741   3                              DisplayData.InitFlag        = TRUE;
 742   3                      } break;
 743   2                      
 744   2                      //---------------------------------------------------------------------------
 745   2                      // FD xA MODE COLOR 00 00 00 FE         
 746   2                      // Set the show mode, color             
 747   2                      //---------------------------------------------------------------------------
 748   2                      case 0xA:
 749   2                      {
 750   3                              // Err check
 751   3                              // DisplayData.Mode             = 0x0~0xA || 0xFF
 752   3                              // ColorNum             = 0x0 ~ 0x1C
 753   3                              if ((RcvData.DataBuf[1] > 0x3) || (RcvData.DataBuf[1] == 0x0))          break;
 754   3                              if (RcvData.DataBuf[2] > 0x8)                                                                                                                                                   break;
 755   3                               
 756   3                              // Get the mode value
 757   3                              DisplayData.Mode                        = RcvData.DataBuf[1] + 0xA;
 758   3                              DisplayData.ModeBuf                     = DisplayData.Mode;
 759   3                              DisplayData.InitFlag            = TRUE;
 760   3                               
 761   3                              // Get the color
 762   3                              DisplayData.ColorValue          = 0x7;
 763   3                              Color_Value_Get(DisplayData.ColorValue);
 764   3                              
 765   3                              FlashSaveFlag                           = TRUE;
 766   3                      } break;
 767   2                      
 768   2                      
 769   2                      
 770   2                      
 771   2                      //---------------------------------------------------------------------------
 772   2                      // process the synchronizaton data 
 773   2                      // if the device's mode or theme isn't as same as received data
 774   2                      // Change the device's mode or color
 775   2                      //---------------------------------------------------------------------------
 776   2                      case 0xF:
 777   2                      {
 778   3                              if (RcvData.DataBuf[1] > 0xA && DisplayData.Mode != 0)
 779   3                              {
 780   4                                      if (DisplayData.Mode != RcvData.DataBuf[1])
 781   4                                      {
 782   5                                              DisplayData.Mode                = RcvData.DataBuf[1];
 783   5                                              DisplayData.ModeBuf     = RcvData.DataBuf[1];
 784   5                                              DisplayData.InitFlag    = TRUE;
 785   5                                              FlashSaveFlag                   = TRUE;
 786   5                          DisplayData.ColorValue  = 0x7;
 787   5                                              Color_Value_Get(0x7);
 788   5                                      }
 789   4                              }
 790   3                      } break;
 791   2                      
 792   2                              
 793   2                      /*
 794   2                       * Password Set
 795   2                       * Test -  x8 01 CRCH CRCL 00 00  --- BLUE Flash
 796   2                       * Set Confirm - x8 02 CRCH CRCL 00 00, return x8 02 CRCH CRCL 
 797   2                       * Set Password - x7 ID1 ID2 ID3 ID4 CHK
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 14  

 798   2                       * Successfully - GREEN FLASH
 799   2                       */
 800   2                      case 0x7:
 801   2                      {
 802   3                              if (PasswordFlag == TRUE)
 803   3                              {
 804   4                                      PasswordFlag = FALSE;
 805   4                                      if ((RcvData.DataBuf[1] ^ RcvData.DataBuf[2] ^ RcvData.DataBuf[3] ^ RcvData.DataBuf[4]) != RcvData.Dat
             -aBuf[5])                // Password is wrong
 806   4                                      {
 807   5                                              DisplayData.Mode = 0xFF;
 808   5                                              DisplayData.InitFlag = TRUE;
 809   5                                              SndData.SndStatus       = SND_NORMAL;
 810   5                                              SndData.DataBuf[0]      = 0x8;
 811   5                                              SndData.DataBuf[1]      = 0x4;
 812   5                                              SndData.DataBuf[2]      = 0;
 813   5                                              SndData.DataBuf[3]      = 0;
 814   5                                              SndData.DataBuf[4]      = NewChkSumH;
 815   5                                              SndData.DataBuf[5]      = NewChkSumL;
 816   5                                              SndData.DataBuf[6]      = ChkSumH;
 817   5                                              SndData.DataBuf[7]      = ChkSumL;
 818   5                                              break;
 819   5                                      }
 820   4                                      
 821   4                                      ChkSumBuf = CRC16_Cal(&RcvData.DataBuf[1]);
 822   4                                      if (ChkSumBuf != (_Uint16)(((_Uint16)NewChkSumH << 8) + (_Uint16)NewChkSumL))
 823   4                                      {
 824   5                                              DisplayData.Mode = 0xFF;
 825   5                                              DisplayData.InitFlag = TRUE;                            //ID1 ID2 ID3 ID4 CRC16-CCITT-FALSE  isn't equal the new checksum
 826   5                                              SndData.SndStatus       = SND_NORMAL;
 827   5                                              SndData.DataBuf[0]      = 0x8;
 828   5                                              SndData.DataBuf[1]      = 0x4;
 829   5                                              SndData.DataBuf[2]      = 0;
 830   5                                              SndData.DataBuf[3]      = 0;
 831   5                                              SndData.DataBuf[4]      = NewChkSumH;
 832   5                                              SndData.DataBuf[5]      = NewChkSumL;
 833   5                                              SndData.DataBuf[6]      = ChkSumH;
 834   5                                              SndData.DataBuf[7]      = ChkSumL;
 835   5                          break;
 836   5                                      }
 837   4                                      
 838   4                                      // Set the pass word
 839   4                                      ChkSumReply[0]          = Hex_To_Char(NewChkSumH >> 4);
 840   4                                      ChkSumReply[1]          = Hex_To_Char(NewChkSumH & 0x0F);
 841   4                                      ChkSumReply[2]          = Hex_To_Char(NewChkSumL >> 4);
 842   4                                      ChkSumReply[3]          = Hex_To_Char(NewChkSumL & 0x0F);
 843   4                                      SndData.SndStatus       = SND_TYPE;                                                             // First send FC 'L' 'B' 'NUM' FE to change the broadcast name, 
             -then reply the APP
 844   4                                      SndData.DataBuf[0]      = 0x8;
 845   4                                      SndData.DataBuf[1]      = 0x3;
 846   4                                      SndData.DataBuf[2]      = 0;
 847   4                                      SndData.DataBuf[3]      = 0;
 848   4                                      SndData.DataBuf[4]      = NewChkSumH;
 849   4                                      SndData.DataBuf[5]      = NewChkSumL;
 850   4                                      SndData.DataBuf[6]      = ChkSumH;
 851   4                                      SndData.DataBuf[7]      = ChkSumL;
 852   4                                      ChkSumH                         = NewChkSumH;
 853   4                                      ChkSumL                         = NewChkSumL;
 854   4                                      NewChkSumH                      = 0;
 855   4                                      NewChkSumL                      = 0;
 856   4                                      
 857   4                                      DisplayData.Mode            = 0xFD;
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 15  

 858   4                                      DisplayData.InitFlag    = TRUE;
 859   4                                      FlashSaveFlag                   = TRUE;
 860   4                              }
 861   3                              
 862   3                              // time out
 863   3                              else
 864   3                              {
 865   4                                      SndData.SndStatus       = SND_NORMAL;
 866   4                                      SndData.DataBuf[0]      = 0x8;
 867   4                                      SndData.DataBuf[1]      = 0x4;
 868   4                                      SndData.DataBuf[2]      = 0;
 869   4                                      SndData.DataBuf[3]      = 0;
 870   4                                      SndData.DataBuf[4]      = NewChkSumH;
 871   4                                      SndData.DataBuf[5]      = NewChkSumL;
 872   4                                      SndData.DataBuf[6]      = ChkSumH;
 873   4                                      SndData.DataBuf[7]      = ChkSumL;
 874   4                              }
 875   3                      } break;
 876   2                      
 877   2                      case 0x8:
 878   2                      {
 879   3                              if (RcvData.DataBuf[1] == 0x1)
 880   3                              {
 881   4                                      DisplayData.Mode                = 0xFB;
 882   4                                      DisplayData.InitFlag    = TRUE;
 883   4                              }
 884   3                              else if (RcvData.DataBuf[1] == 0x2)
 885   3                              {
 886   4                                      PasswordFlag = TRUE;                                                            // Allow set the password within 5 seconds
 887   4                                      
 888   4                                      NewChkSumH = RcvData.DataBuf[2];
 889   4                                      NewChkSumL = RcvData.DataBuf[3];
 890   4                                      SndData.SndStatus       = SND_NORMAL;
 891   4                                      SndData.DataBuf[0]      = RcvData.DataBuf[0];
 892   4                                      SndData.DataBuf[1]      = 0x2;
 893   4                                      SndData.DataBuf[2]      = 0;
 894   4                                      SndData.DataBuf[3]      = 0;
 895   4                                      SndData.DataBuf[4]      = NewChkSumH;
 896   4                                      SndData.DataBuf[5]      = NewChkSumL;
 897   4                                      SndData.DataBuf[6]      = ChkSumH;
 898   4                                      SndData.DataBuf[7]      = ChkSumL;
 899   4                              }
 900   3                      } break;
 901   2                      
 902   2                      
 903   2                      /*
 904   2                       * TEST command 1,2...
 905   2                       * xD 00 00 00 00 00
 906   2                       * xD 01 00 00 00 00
 907   2                       * Reply the equipment type and HSE status, version number...
 908   2                       */
 909   2                      case 0xD:
 910   2                      {
 911   3                              if (RcvData.DataBuf[1] == 0x0)
 912   3                              {
 913   4                                      SndData.SndStatus       = SND_NORMAL;
 914   4                                      SndData.DataBuf[0]      = 0xD;
 915   4                                      SndData.DataBuf[1]      = DEVICE_NAME_ONE;
 916   4                                      SndData.DataBuf[2]      = DEVICE_NAME_TWO;
 917   4                                      SndData.DataBuf[3]      = DEVICE_NUM;
 918   4                                      SndData.DataBuf[4]      = 0;                    
 919   4                                      SndData.DataBuf[5]      = TimerData.CntDwnHour;
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 16  

 920   4                                      SndData.DataBuf[6]      = ChkSumH;
 921   4                                      SndData.DataBuf[7]      = ChkSumL;
 922   4                                      break;
 923   4                              }
 924   3                              
 925   3                              if (RcvData.DataBuf[1] == 0x1)
 926   3                              {
 927   4                                      SndData.SndStatus       = SND_NORMAL;
 928   4                                      SndData.DataBuf[0]      = 0xD;
 929   4                                      SndData.DataBuf[1]      = HseStatus;                                                    // HSE status
 930   4                                      SndData.DataBuf[2]      = 0;                                                    // Watch Dog status
 931   4                                      SndData.DataBuf[3]      = PROTOCOL_VER;                                             // Protocol version
 932   4                                      SndData.DataBuf[4]      = SOFT_VER;                                                             // Software version
 933   4                                      SndData.DataBuf[5]      = 0x18;                                                                 // Year 2018                                                                    
 934   4                                      SndData.DataBuf[6]      = 'W';                                                                  // Company Willis Co.
 935   4                                      SndData.DataBuf[7]      = 'C';                                                                  // Author DS.Chin(James.Chin or Jim.C)
 936   4                              }
 937   3                      } break;
 938   2              }
 939   1      }
 940          
 941          
 942          /*******************************************************************************
 943                  *
 944                  * FunctionName          CRC16_Cal
 945                  *
 946          ********************************************************************************/
 947          _Uint16 CRC16_Cal(_Uint8 Buffer[])
 948          {
 949   1              _Uint16         ResultBuf   = 0x0000;
 950   1              _Uint8          CntBuf      = 0;
 951   1              _Uint8          BitBuf      = 0;
 952   1              
 953   1              for (CntBuf = 0; CntBuf < 4; CntBuf++)
 954   1              {
 955   2                      ResultBuf ^= ((_Uint16)Buffer[CntBuf] << 8);
 956   2                      
 957   2                      for (BitBuf = 0; BitBuf < 8; BitBuf++)
 958   2                      {
 959   3                              if ((ResultBuf & 0x8000) == 0x8000)
 960   3                              {
 961   4                                      ResultBuf = (ResultBuf << 1) ^ 0x1021;
 962   4                              }
 963   3                              else
 964   3                              {
 965   4                                      ResultBuf <<= 1;
 966   4                              }
 967   3                      }
 968   2              }
 969   1              
 970   1              return ResultBuf;
 971   1      }
 972          
 973          /****************************************************************************
 974           * Color_Value_Get
 975           */
 976          void Color_Value_Get(_Uint8 ColorNumBuf)
 977          {
 978   1              _Uint8  TempCnt = 0;
 979   1              
 980   1              if (DisplayData.Mode > 0xA)
 981   1              {
C51 COMPILER V9.52.0.0   DATA_PROCESS                                                      03/19/2018 13:49:42 PAGE 17  

 982   2                      for (TempCnt = 0; TempCnt < 7; TempCnt++)
 983   2                      {
 984   3                              ColorData[TempCnt][0] = COLOR_VECTOR[TempCnt + 1][0];
 985   3                              ColorData[TempCnt][1] = COLOR_VECTOR[TempCnt + 1][1];
 986   3                              ColorData[TempCnt][2] = COLOR_VECTOR[TempCnt + 1][2];
 987   3                      }
 988   2              }
 989   1              else
 990   1              {
 991   2                      ColorData[0][0] = COLOR_VECTOR[ColorNumBuf][0];
 992   2                      ColorData[0][1] = COLOR_VECTOR[ColorNumBuf][1];
 993   2                      ColorData[0][2] = COLOR_VECTOR[ColorNumBuf][2];
 994   2              }
 995   1      }
 996          
 997          
 998          
 999          
1000          
1001          
1002          /************************************************************************
1003           *
1004           * FunctionName   Hex_To_Char
1005           *
1006           *  Input                                        HexBuf
1007           *                                                               HexBuf < 0x10
1008          *************************************************************************/
1009          static _Uint8           Hex_To_Char(_Uint8 HexBuf)
1010          {
1011   1              if (HexBuf > 0x0F)              HexBuf &= 0x0F;
1012   1              
1013   1              //Hex = 0x0,0x1...0x9
1014   1              if (HexBuf < 0xA) 
1015   1              {
1016   2                      return (HexBuf + '0');
1017   2              }
1018   1              
1019   1              // Hex = 0xA,0xB ... 0xF
1020   1              HexBuf -= 0xA;
1021   1              return (HexBuf + 'A');
1022   1      }
1023          
1024          
1025          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1705    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29       7
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
